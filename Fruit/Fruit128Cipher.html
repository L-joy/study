<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    let LFSR = new Array(65);
    let NFSR = new Array(63);
    let Cr = new Array(10);
    let Cc = new Array(7);
    // 00000001001000110100010101100111100011000011010101111101101111011110001011010010
    let key = "00000001001000110100010101100111100011000011010101111101101111011110001011010010" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "11110110";
    let IV = "1000000000" +
        "0000000100100011010001010110011110001001101010111100110111101111010111" +
        "0000010000" +
        "0000000100" +
        "0001000000" +
        "0010000000" +
        "00100010" +
        "0000000000" +
        "0000000000" + "01";
    // 密钥装载阶段
    function frvit128() {
        if (key.length !== 128) {
            console.log("error");
        }
        for (let i = 0; i < NFSR.length; i++) {
            NFSR[i] = key.charAt(i) === '1' ? 1 : 0;
        }
        let j = 0;
        for (let i = NFSR.length; i < NFSR.length + LFSR.length; i++) {
            LFSR[j] = key.charAt(i) === '1' ? 1 : 0;
            j++;
        }
        for (let i = 0; i < Cr.length; i++) {
            Cr[i] = 0;
        }
        for (let i = 0; i < Cc.length; i++) {
            Cc[i] = 0;
        }
    }
    // 初始化阶段
    function init() {
        frvit128();
        // 第一轮初始化
        let fb = 0;
        for (let i = 0; i < 150; i++) {
            clockOneTime(fb);
            let z = output();
            let iv = IV.charAt(i) === '1' ? 1 : 0;
            fb = z ^ iv
        }
        // 第二轮初始化
        LFSR[0] = 1;
        for (let i = 0; i < Cr.length; i++) {
            Cr[i] = NFSR[i];
        }
        for (let i = 0; i < Cc.length; i++) {
            Cc[i] = LFSR[i];
        }
        // console.log('第二轮————————————————————————————', Cr);

        // let flag = true;
        // for (let i = 0; i < Cc.length; i++) {
        //     if (Cc[i] !== 1) {
        //         flag = false;
        //     }

        // }
        // while (!flag) {
        //     clockOneTime(0);
        // }

    }
    // 轮密钥函数
    function keyRound(flag) {
        let r = parseInt((Cr[4]) * Math.pow(2, 0)) +
            parseInt((Cr[3]) * Math.pow(2, 1)) +
            parseInt((Cr[2]) * Math.pow(2, 2)) +
            parseInt((Cr[1]) * Math.pow(2, 3)) +
            parseInt((Cr[0]) * Math.pow(2, 4));
        let s = parseInt((Cr[9]) * Math.pow(2, 0)) +
            parseInt((Cr[8]) * Math.pow(2, 1)) +
            parseInt((Cr[7]) * Math.pow(2, 2)) +
            parseInt((Cr[6]) * Math.pow(2, 3)) +
            parseInt((Cr[5]) * Math.pow(2, 4)) + 32;
        let p = parseInt((Cr[6]) * Math.pow(2, 0)) +
            parseInt((Cr[5]) * Math.pow(2, 1)) +
            parseInt((Cr[4]) * Math.pow(2, 2)) +
            parseInt((Cr[3]) * Math.pow(2, 3)) +
            parseInt((Cr[2]) * Math.pow(2, 4)) + 64;
        let q = parseInt((Cr[1]) * Math.pow(2, 0)) +
            parseInt((Cr[0]) * Math.pow(2, 1)) +
            parseInt((Cr[9]) * Math.pow(2, 2)) +
            parseInt((Cr[8]) * Math.pow(2, 3)) +
            parseInt((Cr[7]) * Math.pow(2, 4)) + 96;
        let gk = (parseInt(key.charAt(r)) & parseInt(key.charAt(s)) & parseInt(key.charAt(p))) ^
            (parseInt(key.charAt(r)) & parseInt(key.charAt(p))) ^
            (parseInt(key.charAt(s)) & parseInt(key.charAt(q))) ^
            parseInt(key.charAt(s)) ^ parseInt(key.charAt(q)) ^
            parseInt(key.charAt(p));
        let hk = (parseInt(key.charAt(r)) & parseInt(key.charAt(s)) & parseInt(key.charAt(q))) ^
            (parseInt(key.charAt(r)) & parseInt(key.charAt(s))) ^
            (parseInt(key.charAt(p)) & parseInt(key.charAt(q))) ^
            parseInt(key.charAt(r)) ^ parseInt(key.charAt(s)) ^ parseInt(key.charAt(p));
        if (flag) {
            return gk;
        } else {
            return hk;
        }
    }
    // NFSR反馈函数
    function feedbackNFSR() {
        let y = parseInt((Cr[9]) * Math.pow(2, 0)) +
            parseInt((Cr[8]) * Math.pow(2, 1)) +
            parseInt((Cr[7]) * Math.pow(2, 2)) +
            parseInt((Cr[6]) * Math.pow(2, 3)) +
            parseInt((Cr[5]) * Math.pow(2, 4)) +
            parseInt((Cr[4]) * Math.pow(2, 5)) +
            parseInt((Cr[3]) * Math.pow(2, 6));
        let vt = IV.charAt(y) === '1' ? 1 : 0;
        let g;
        g = keyRound(1) ^ LFSR[0] ^ vt ^ Cr[6] ^ NFSR[0] ^ NFSR[10] ^ NFSR[29] ^ NFSR[50] ^
            (NFSR[62] & NFSR[60]) ^ (NFSR[15] & NFSR[40]) ^ (NFSR[25] & NFSR[46]) ^
            (NFSR[1] & NFSR[3]) ^ (NFSR[38] & NFSR[35]) ^
            (NFSR[8] & NFSR[19] & NFSR[28]) ^
            (NFSR[48] & NFSR[55] & NFSR[57] & NFSR[59]);
        return g;
    }

    // LFSR反馈函数
    function feedbackLFSR() {
        return LFSR[63] ^ LFSR[61] ^ LFSR[53] ^ LFSR[33] ^ LFSR[7] ^ LFSR[0];
    }

    function output() {
        let z;
        let h;
        h = (keyRound(0) & NFSR[62]) ^ (keyRound(0) & NFSR[1]) ^
            (LFSR[1] & LFSR[45]) ^
            (LFSR[9] & LFSR[57]) ^
            (NFSR[37] & LFSR[25]) ^
            (NFSR[11] & LFSR[64]) ^
            (LFSR[29] & LFSR[17]) ^
            (NFSR[61] & NFSR[62]) ^
            (NFSR[1] & NFSR[2] & LFSR[49]);

        z = h ^ NFSR[3] ^ NFSR[27] ^ NFSR[47] ^ NFSR[43] ^ NFSR[19] ^ NFSR[53] ^ NFSR[60] ^ LFSR[37];
        return z;
    }

    function clockOneTime(fb) {
        let fbLFSR = feedbackLFSR();
        let fbNFSR = feedbackNFSR();

        for (let i = 0; i < LFSR.length - 1; i++) {
            LFSR[i] = LFSR[i + 1];
        }
        for (let i = 0; i < NFSR.length - 1; i++) {
            NFSR[i] = NFSR[i + 1];
        }

        NFSR[62] = fbNFSR ^ fb;
        LFSR[64] = fbLFSR ^ fb;

        let temp = 0,
            j = 0;
        for (let i = Cr.length - 1; i >= 0; i--) {
            temp += Cr[i] * Math.pow(2, j);
            j++;
        }
        temp = temp + 1;
        count(temp);
    }

    function count(temp) {
        for (let i = Cr.length - 1; i >= 0; i--) {
            Cr[i] = (temp % 2 == 1) ? 1 : 0;
            temp = parseInt(temp / 2);
        }
        // console.log(Cr);
    }

    function stream() {
        init();
        let Stream = [];
        for (let i = 0; i <32; i++) {
            Stream.push(output(LFSR, NFSR));
            clockOneTime(0, LFSR, NFSR);
        }
        // console.log('无错误密钥流', Stream.join(""));
        return Stream;
    }

    function faultStream(n) {
        init();
        if (LFSR[n] === 1) {
            LFSR[n] = 0;
        } else {
            LFSR[n] = 1;
        }
        let Stream = [];
        for (let i = 0; i <32; i++) {
            Stream.push(output(LFSR, NFSR));
            clockOneTime(0, LFSR, NFSR);
        }
        // console.log('有错误密钥流', Stream.join(""));
        return Stream;
    }
    // stream();
    // faultStream(8);


    function bin_to_hex(str) {
        let hex_array = [{
                key: 0,
                val: "0000"
            }, {
                key: 1,
                val: "0001"
            }, {
                key: 2,
                val: "0010"
            }, {
                key: 3,
                val: "0011"
            }, {
                key: 4,
                val: "0100"
            }, {
                key: 5,
                val: "0101"
            }, {
                key: 6,
                val: "0110"
            }, {
                key: 7,
                val: "0111"
            },
            {
                key: 8,
                val: "1000"
            }, {
                key: 9,
                val: "1001"
            }, {
                key: 'a',
                val: "1010"
            }, {
                key: 'b',
                val: "1011"
            }, {
                key: 'c',
                val: "1100"
            }, {
                key: 'd',
                val: "1101"
            }, {
                key: 'e',
                val: "1110"
            }, {
                key: 'f',
                val: "1111"
            }
        ]
        let value = ''
        let list = []
        if (str.length % 4 !== 0) {
            let a = "0000"
            let b = a.substring(0, 4 - str.length % 4)
            str = b.concat(str)
        }
        while (str.length > 4) {
            list.push(str.substring(0, 4))
            str = str.substring(4);
        }
        list.push(str)
        for (let i = 0; i < list.length; i++) {
            for (let j = 0; j < hex_array.length; j++) {
                if (list[i] == hex_array[j].val) {
                    value = value.concat(hex_array[j].key)
                    break
                }
            }
        }
        return value
    }

    function round(r) {
        let h = [
            ['n62'],
            ['n1'],
            ['l1', 'l45'],
            ['l9', 'l57'],
            ['n37', 'l25'],
            ['n11', 'l64'],
            ['l29', 'l17'],
            ['n61', 'n62'],
            ['n2', 'n1', 'l49']
        ];
        let b = ['n3', 'n27', 'n47', 'n43', 'n19', 'n53', 'n60', 'l37'];
        for (let l = 0; l < r; l++) {
            for (let i = 0; i < b.length; i++) {
                let x = b[i].slice(0, 1);
                let n = parseInt(b[i].slice(1));
                if (x === 'l' && n === 64) {
                    b[i] = 'l0';
                    b.push(...['l6', 'l32', 'l52', 'l60', 'l62'])
                } else if (x === 'n' && n === 62) {
                    b[i] = 'l0';
                } else {
                    n = n + 1;
                    b[i] = x + n;
                }
            }
            let clockH = h;
            for (let i = 0; i < h.length; i++) {
                for (let j = 0; j < h[i].length; j++) {
                    let x = h[i][j].slice(0, 1);
                    let n = parseInt(h[i][j].slice(1));
                    if (x === 'l' && n === 64) {
                        h[i][j] = 'l0';
                        h[i].push(...['l6', 'l32', 'l52', 'l60', 'l62'])
                    } else if (x === 'n' && n === 62) {
                        h[i][j] = 'l0';
                    } else {
                        n = n + 1;
                        h[i][j] = x + n;
                    }
                }
            }
        }
        return [h, b];

    }

    function PRGA() {
        let resAll = [];
        let resAllCount = [];
        for (let l = 0; l < 65; l++) {
            let res = [];
            let resCount = 0;

            for (let i = 0; i <32; i++) {
                let temp = round(i);
                let count = 0;
                for (let bi = 0; bi < temp[1].length; bi++) {
                    const element = temp[1][bi];
                    if (element === 'l' + l) {
                        count++;
                    }
                }

                for (let hi = 0; hi < temp[0].length; hi++) {
                    for (let hj = 0; hj < temp[0][hi].length; hj++) {
                        const element = temp[0][hi][hj];
                        if (element === 'l' + l) {
                            count++;
                        }
                    }
                }
                if (count !== 0) {
                    res.push(0);
                } else {
                    res.push(1);
                    resCount++;
                }
            }
            resAll.push(res);
            resAllCount.push(resCount);
        }

        // console.log(resAllCount);
        return resAll;
    }

    function PRGASgn2() {
        let resAll = [];
        let resAllCount = [];
        for (let l = 0; l < 65; l++) {
            let res = [];
            let resCount = 0;

            for (let i = 0; i < 32; i++) {
                let flag = true;
                let temp = round(i);
                let count = 0;
                for (let bi = 0; bi < temp[1].length; bi++) {
                    const element = temp[1][bi];
                    if (element === 'l' + l) {
                        count++;
                    }
                }
                for (let hi = 0; hi < temp[0].length; hi++) {
                    for (let hj = 0; hj < temp[0][hi].length; hj++) {
                        const element = temp[0][hi][hj];
                        if (element === 'l' + l) {
                            flag = false;
                        }
                    }
                }
                if (flag && count !== 0 && count % 2 !== 0) {
                    res.push(1);
                    resCount++;
                } else {
                    res.push(0);
                }
            }
            resAll.push(res);
            resAllCount.push(resCount);
        }

        // console.log(resAllCount);
        return resAll;
    }

    function f() {
        let f1All = [];
        for (let i = 0; i < 65; i++) {
            let s = stream(),
                sf = faultStream(i);
            let res = [];
            for (let i = 0; i < s.length; i++) {
                if (s[i] === sf[i]) {
                    res.push(1);
                } else {
                    res.push(0);
                }
            }

            let sgn = PRGA();
            let f1 = [];
            for (let i = 0; i < sgn.length; i++) {
                if (isSubset(res, sgn[i])) {
                    f1.push(i);
                }
            }
            f1All.push(f1)
        }

        return f1All;
    }

    // console.log(f());

    function isSubset(res, sgn) {
        for (let i = 0; i < sgn.length; i++) {
            if (sgn[i] === 1 && res[i] !== 1) {
                return false;
            }
        }
        return true;
    }

    function currentKeySgn1() {
        let allP = 0;
        for (let i = 0; i < Math.pow(2, 3); i++) {
            key = "00000001001000110100010101100111100011000011010101111101101111011110001011010010" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "11110";
            let temp = i.toString(2);
            let res = temp;
            if (temp.length < 3) {
                for (let i = 0; i < 3 - temp.length; i++) {
                    res = '0' + res
                }
            }
            key = key + res;
            let f1 = f();
            let count = 0;
            for (let i = 0; i < f1.length; i++) {
                const element = f1[i];
                if (f1[i] && f1[i].indexOf(i) !== -1) {
                    count++;
                }
            }
            if (parseFloat(count / f1.length) === 1) {
                console.log(key);
            }
            allP = allP + parseFloat(count / f1.length);
            console.log("单个准确率", parseFloat(count / f1.length));
        }
        console.log("整体准确率", parseFloat(allP / Math.pow(2, 3)));
    }
    // currentKeySgn1();

    function sgn2() {
        let sgn2 = PRGASgn2();
        let f1 = f();
        console.log(f1);
        let f2All = [];
        for (let i = 0; i < f1.length; i++) {
            let element = f1[i];
            let f2 = [];
            for (let j = 0; j < element.length; j++) {
                let faultLocation = element[j];
                // console.log("错误位置：",faultLocation);
                let s = stream(),
                    sf = faultStream(faultLocation);
                let res = [];
                for (let i = 0; i < s.length; i++) {
                    if (s[i] !== sf[i]) {
                        res.push(1);
                    } else {
                        res.push(0);
                    }
                }
                // console.log(res);
                // console.log(sgn2[i]);
                if (element.length === 0) {
                    f2.push();
                } else if (element.length === 1) {
                    f2.push(faultLocation);
                } else if (isSubset(res, sgn2[i])) {
                    f2.push(faultLocation);
                }
            }
            f2All.push(f2);
        }
        return f2All;
    }

    console.log(sgn2())

    function currentKeySgn2() {
        let allP = 0;
        for (let i = 0; i < Math.pow(2, 5); i++) {
            key = "00000001001000110100010101100111100011000011010101111101101111011110001011010010" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "1111011011" +
                "11110110";
            let temp = i.toString(2);
            let res = temp;
            if (temp.length < 5) {
                for (let i = 0; i < 5 - temp.length; i++) {
                    res = '0' + res
                }
            }
            key = key + res;
            let f1 = sgn2();
            let count = 0;
            for (let i = 0; i < f1.length; i++) {
                const element = f1[i];
                if (f1[i] && f1[i].indexOf(i) !== -1) {
                    count++;
                }
            }
            if (parseFloat(count / f1.length) === 1) {
                console.log(key);
            }
            allP = allP + parseFloat(count / f1.length);
            console.log("单个准确率", parseFloat(count / f1.length));
        }
        console.log("整体准确率", parseFloat(allP / Math.pow(2, 5)));
    }
    // currentKeySgn2();
</script>

</html>