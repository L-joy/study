<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		function BinarySearchTree(){
			let root = null;
			this.insert = insert;//插入值
			this.search = search;//在树中查找一个值,如果节点存在,返回true
			this.min = min;//返回树中最小值
			this.max = max;//返回树中最大值
			this.inOrderTraverse = inOrderTraverse;  //inOrderTraverse：通过中序遍历方式遍历所有节点。
			this.preOrderTraverse = preOrderTraverse;  //preOrderTraverse：通过先序遍历方式遍历所有节点。
			this.postOrderTraverse = postOrderTraverse;  //postOrderTraverse：通过后序遍历方式遍历所有节点。
			this.remove = remove;    //remove(key)：从树中移除某个键。
		}
		function Node(key){
			this.key = key;
			this.left = null;
			this.right = null;
		}
		//向树中插入某个值
		function insert(key){
			let newNode = new Node(key)
			if(this.root == null){
				this.root = newNode;
			}else{
				insertNode(this.root,newNode);
			}
		}
		function insertNode(node,newNode){
			if(newNode.key < node.key){
				if(node.left === null){
					node.left = newNode;
				}else{
					insertNode(node.left,newNode)
				}
			}else{
				if(node.right === null){
					node.right = newNode;
				}else{
					insertNode(node.right,newNode)
				}
			}
		
		}
		function search(key){
			return searchNode(this.root,key);
		}
		function searchNode(node,key){
			if(node == null){
				return false;
			}
			if(node.key > key){
				return searchNode(node.left,key);
			}else if(node.key < key){
				return searchNode(node.right,key);
			}else{
				return true;
			}
		}
		function min(){
			let node = this.root;
			if(node){
				while(node&&node.left){
					node = node.left
				}
				return node.key;
			}
			return null;
		}
		function max(){
			let node = this.root;
			if(node){
				while(node&&node.right){
					node = node.right
				}
				return node.key;
			}
			return null;
		}
		function inOrderTraverse(){
			let res = [];
			inOrder(this.root,res);
			return res;
		}
		function inOrder(node,res){
			if(node){
				inOrder(node.left,res);
				res.push(node.key);
				inOrder(node.right,res);
			}
		}
		function preOrderTraverse(){
			let res = [];
			preOrder(this.root,res);
			return res;
		}
		function preOrder(node,res){
			if(node){
				res.push(node.key);
				preOrder(node.left,res);
				preOrder(node.right,res)
			}
		}
		function postOrderTraverse(){
			let res = [];
			postOrder(this.root,res);
			return res;
		}
		function postOrder(node,res){
			if(node){
				postOrder(node.left,res);
				postOrder(node.right,res);
				res.push(node.key);
			}
		}
		function remove(){
			console.log(111)
		}
		let BST = new BinarySearchTree();
		BST.insert(45)
		BST.insert(20)
		BST.insert(90)
		BST.insert(10)
		BST.insert(15)
		BST.insert(70)
		BST.insert(100)
		BST.insert(12)
		BST.insert(22)
		console.log(BST.search(60))
		console.log(BST.search(61))
		console.log(BST.min())
		console.log(BST.max())
		console.log(BST.inOrderTraverse())
		console.log(BST.preOrderTraverse())
		console.log(BST.postOrderTraverse())
		console.log(BST)
	</script>
</html>
